<!DOCTYPE html>
<html lang="id">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Developer Guide - Document Similarity Analyzer</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"
    />
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"
    ></script>
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
    ></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.8;
        color: #333;
        background: #fff;
        max-width: 900px;
        margin: 0 auto;
        padding: 40px 20px;
      }

      h1 {
        text-align: center;
        color: #2c3e50;
        font-size: 28pt;
        margin-bottom: 10px;
        border-bottom: 3px solid #3498db;
        padding-bottom: 15px;
      }

      .subtitle {
        text-align: center;
        color: #7f8c8d;
        font-size: 14pt;
        margin-bottom: 40px;
      }

      h2 {
        color: #2980b9;
        font-size: 18pt;
        margin-top: 40px;
        margin-bottom: 20px;
        padding-bottom: 8px;
        border-bottom: 2px solid #ecf0f1;
      }

      h3 {
        color: #34495e;
        font-size: 14pt;
        margin-top: 25px;
        margin-bottom: 12px;
      }

      p {
        margin-bottom: 15px;
        text-align: justify;
      }

      .highlight-box {
        background: #e8f6ff;
        border-left: 4px solid #3498db;
        padding: 15px 20px;
        margin: 20px 0;
        border-radius: 0 8px 8px 0;
      }

      .highlight-box.warning {
        background: #fff9e6;
        border-left-color: #f1c40f;
      }

      .highlight-box.success {
        background: #e8f8f0;
        border-left-color: #27ae60;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
      }

      th,
      td {
        border: 1px solid #ddd;
        padding: 12px 15px;
        text-align: left;
      }

      th {
        background: #3498db;
        color: white;
      }

      tr:nth-child(even) {
        background: #f9f9f9;
      }

      .code-block {
        background: #2d2d2d;
        color: #f8f8f2;
        padding: 20px;
        border-radius: 8px;
        overflow-x: auto;
        margin: 20px 0;
        font-family: "Consolas", "Monaco", monospace;
        font-size: 10pt;
        line-height: 1.6;
      }

      .code-block pre {
        margin: 0;
        white-space: pre;
        overflow-x: auto;
      }

      .code-block .comment {
        color: #6a9955;
      }
      .code-block .keyword {
        color: #569cd6;
      }
      .code-block .function {
        color: #dcdcaa;
      }
      .code-block .string {
        color: #ce9178;
      }
      .code-block .type {
        color: #4ec9b0;
      }
      .code-block .number {
        color: #b5cea8;
      }

      .math-block {
        background: #f8f9fa;
        padding: 20px;
        margin: 20px 0;
        border-radius: 8px;
        text-align: center;
        border: 1px solid #e9ecef;
      }

      .example-box {
        background: #f0f7ff;
        border: 1px solid #b8d4f0;
        padding: 20px;
        margin: 20px 0;
        border-radius: 8px;
      }

      .example-box h4 {
        color: #2980b9;
        margin-bottom: 10px;
      }

      ul,
      ol {
        margin-left: 25px;
        margin-bottom: 15px;
      }

      li {
        margin-bottom: 8px;
      }

      .toc {
        background: #f8f9fa;
        padding: 25px;
        border-radius: 8px;
        margin-bottom: 40px;
      }

      .toc h3 {
        margin-top: 0;
        color: #2c3e50;
      }

      .toc ul {
        list-style: none;
        margin-left: 0;
      }

      .toc li {
        padding: 5px 0;
      }

      .toc a {
        color: #3498db;
        text-decoration: none;
      }

      .toc a:hover {
        text-decoration: underline;
      }

      .diagram {
        text-align: center;
        margin: 25px 0;
        padding: 20px;
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 8px;
      }

      .pipeline-flow {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
        gap: 10px;
        margin: 20px 0;
      }

      .pipeline-step {
        background: #3498db;
        color: white;
        padding: 10px 15px;
        border-radius: 5px;
        font-weight: bold;
        font-size: 10pt;
      }

      .pipeline-arrow {
        font-size: 20pt;
        color: #7f8c8d;
      }

      @media print {
        body {
          max-width: 100%;
          padding: 20px;
        }

        .code-block {
          background: #f5f5f5 !important;
          color: #333 !important;
          border: 1px solid #ddd;
        }

        .code-block .comment {
          color: #008000 !important;
        }
        .code-block .keyword {
          color: #0000ff !important;
        }
        .code-block .function {
          color: #795e26 !important;
        }
        .code-block .string {
          color: #a31515 !important;
        }
        .code-block .type {
          color: #267f99 !important;
        }
      }
    </style>
  </head>
  <body>
    <h1>Developer Guide</h1>
    <p class="subtitle">
      Document Similarity Analyzer - Panduan untuk Presentasi
    </p>

    <div class="toc">
      <h3>üìã Daftar Isi</h3>
      <ul>
        <li>1. <a href="#tech-stack">Tech Stack & Fungsinya</a></li>
        <li>
          2. <a href="#algoritma">Algoritma: TF-IDF dan Cosine Similarity</a>
        </li>
        <li>3. <a href="#contoh">Contoh Perhitungan Manual</a></li>
        <li>4. <a href="#fp">Functional Programming yang Diterapkan</a></li>
        <li>5. <a href="#kode">Kode Utama & Penjelasan</a></li>
        <li>6. <a href="#faq">FAQ - Pertanyaan yang Mungkin Ditanya</a></li>
      </ul>
    </div>

    <!-- SECTION 1: TECH STACK -->
    <h2 id="tech-stack">1. Tech Stack & Fungsinya</h2>

    <p>
      Berikut adalah teknologi yang digunakan dalam project ini beserta fungsi
      masing-masing:
    </p>

    <table>
      <tr>
        <th>Teknologi</th>
        <th>Versi</th>
        <th>Fungsi</th>
      </tr>
      <tr>
        <td><strong>Rust</strong></td>
        <td>2021 Edition</td>
        <td>
          Bahasa pemrograman utama. Dipilih karena cepat, aman (memory safe),
          dan mendukung functional programming.
        </td>
      </tr>
      <tr>
        <td><strong>Axum</strong></td>
        <td>0.7</td>
        <td>
          Framework web untuk membuat REST API. Menangani HTTP request/response.
        </td>
      </tr>
      <tr>
        <td><strong>Tokio</strong></td>
        <td>1.0</td>
        <td>
          Async runtime. Memungkinkan server menangani banyak request secara
          bersamaan tanpa blocking.
        </td>
      </tr>
      <tr>
        <td><strong>Rayon</strong></td>
        <td>1.8</td>
        <td>
          Library untuk parallel processing. Mempercepat perhitungan dengan
          memanfaatkan semua CPU core.
        </td>
      </tr>
      <tr>
        <td><strong>Serde</strong></td>
        <td>1.0</td>
        <td>Serialization/Deserialization. Mengubah data Rust ‚Üî JSON.</td>
      </tr>
      <tr>
        <td><strong>thiserror</strong></td>
        <td>1.0</td>
        <td>Untuk membuat custom error types yang lebih mudah dibaca.</td>
      </tr>
    </table>

    <div class="highlight-box">
      <strong>üí° Kenapa Rust?</strong><br />
      Rust dipilih karena: (1) Performa setara C/C++, (2) Memory safety tanpa
      garbage collector, (3) Mendukung paradigma functional programming dengan
      baik.
    </div>

    <!-- SECTION 2: ALGORITMA -->
    <h2 id="algoritma">2. Algoritma: TF-IDF dan Cosine Similarity</h2>

    <h3>üéØ Tujuan Utama</h3>
    <p>
      Mengukur seberapa mirip dua dokumen teks. Misalnya, apakah dokumen A dan
      dokumen B membahas topik yang sama?
    </p>

    <h3>üìä Alur Kerja</h3>
    <div class="diagram">
      <div class="pipeline-flow">
        <div class="pipeline-step">Dokumen Teks</div>
        <div class="pipeline-arrow">‚Üí</div>
        <div class="pipeline-step">TF-IDF</div>
        <div class="pipeline-arrow">‚Üí</div>
        <div class="pipeline-step">Vektor Angka</div>
        <div class="pipeline-arrow">‚Üí</div>
        <div class="pipeline-step">Cosine Similarity</div>
        <div class="pipeline-arrow">‚Üí</div>
        <div class="pipeline-step">Skor Kemiripan</div>
      </div>
    </div>

    <div class="highlight-box success">
      <strong>üîó Hubungan TF-IDF dan Cosine Similarity:</strong><br /><br />
      <strong>TF-IDF</strong> = Mengubah teks menjadi
      <em>vektor angka</em> (representasi matematis)<br />
      <strong>Cosine Similarity</strong> = Mengukur
      <em>kemiripan antar vektor</em><br /><br />
      Jadi: TF-IDF adalah <em>cara merepresentasikan</em> dokumen, sedangkan
      Cosine Similarity adalah <em>cara mengukur</em> kemiripannya.
    </div>

    <h3>üìà Term Frequency (TF)</h3>
    <p>
      TF mengukur <strong>seberapa sering</strong> sebuah kata muncul dalam satu
      dokumen.
    </p>

    <div class="math-block">
      $$TF(t, d) = \frac{\text{Jumlah kemunculan kata } t \text{ dalam dokumen }
      d}{\text{Total kata dalam dokumen } d}$$
    </div>

    <p>
      <strong>Contoh:</strong> Dokumen "kucing suka kucing" memiliki 3 kata.
      Kata "kucing" muncul 2 kali.
    </p>
    <p>TF("kucing") = 2/3 = 0.67</p>

    <h3>üìâ Inverse Document Frequency (IDF)</h3>
    <p>
      IDF mengukur <strong>seberapa unik</strong> sebuah kata di seluruh
      dokumen. Kata yang muncul di mana-mana (seperti "dan", "yang") akan
      memiliki IDF rendah.
    </p>

    <div class="math-block">
      $$IDF(t) = \ln\left(\frac{N + 1}{df(t) + 1}\right) + 1$$
    </div>

    <p>Dimana:</p>
    <ul>
      <li><strong>N</strong> = Total jumlah dokumen</li>
      <li><strong>df(t)</strong> = Jumlah dokumen yang mengandung kata t</li>
      <li>
        <strong>+1</strong> = Smoothing, agar tidak terjadi pembagian dengan nol
      </li>
    </ul>

    <div class="highlight-box warning">
      <strong>‚ö†Ô∏è Intuisi IDF:</strong><br />
      Kata yang muncul di <em>semua</em> dokumen ‚Üí IDF rendah (kata tidak
      penting)<br />
      Kata yang muncul di <em>sedikit</em> dokumen ‚Üí IDF tinggi (kata
      unik/penting)
    </div>

    <h3>‚úñÔ∏è TF-IDF</h3>
    <p>TF-IDF adalah hasil perkalian TF dan IDF:</p>

    <div class="math-block">
      $$TF\text{-}IDF(t, d) = TF(t, d) \times IDF(t)$$
    </div>

    <p>Hasilnya adalah vektor angka yang merepresentasikan setiap dokumen.</p>

    <h3>üìê Cosine Similarity</h3>
    <p>
      Setelah dokumen menjadi vektor, kita hitung kemiripannya menggunakan
      Cosine Similarity:
    </p>

    <div class="math-block">
      $$\text{Cosine Similarity}(A, B) = \frac{A \cdot B}{\|A\| \times \|B\|}$$
    </div>

    <p>Dimana:</p>
    <ul>
      <li>
        <strong>A ¬∑ B</strong> = Dot product (perkalian elemen per elemen, lalu
        dijumlahkan)
      </li>
      <li><strong>||A||</strong> = Magnitude/panjang vektor A</li>
    </ul>

    <div class="highlight-box">
      <strong>üìä Interpretasi Hasil:</strong><br />
      <strong>1.0</strong> = Dokumen identik (100% sama)<br />
      <strong>0.0</strong> = Dokumen tidak ada kesamaan sama sekali<br />
      <strong>0.5</strong> = Dokumen cukup mirip (50% kesamaan)
    </div>

    <!-- SECTION 3: CONTOH PERHITUNGAN -->
    <h2 id="contoh">3. Contoh Perhitungan Manual</h2>

    <div class="example-box">
      <h4>üìù Contoh Sederhana</h4>
      <p>Misalkan kita punya 2 dokumen:</p>
      <ul>
        <li><strong>Dokumen 0:</strong> "kucing suka ikan"</li>
        <li><strong>Dokumen 1:</strong> "anjing suka tulang"</li>
      </ul>

      <h4>Langkah 1: Hitung TF</h4>
      <table>
        <tr>
          <th>Kata</th>
          <th>TF (Doc 0)</th>
          <th>TF (Doc 1)</th>
        </tr>
        <tr>
          <td>kucing</td>
          <td>1/3 = 0.33</td>
          <td>0</td>
        </tr>
        <tr>
          <td>suka</td>
          <td>1/3 = 0.33</td>
          <td>1/3 = 0.33</td>
        </tr>
        <tr>
          <td>ikan</td>
          <td>1/3 = 0.33</td>
          <td>0</td>
        </tr>
        <tr>
          <td>anjing</td>
          <td>0</td>
          <td>1/3 = 0.33</td>
        </tr>
        <tr>
          <td>tulang</td>
          <td>0</td>
          <td>1/3 = 0.33</td>
        </tr>
      </table>

      <h4>Langkah 2: Hitung IDF</h4>
      <p>N = 2 dokumen</p>
      <table>
        <tr>
          <th>Kata</th>
          <th>df (muncul di berapa dok)</th>
          <th>IDF = ln((2+1)/(df+1)) + 1</th>
        </tr>
        <tr>
          <td>kucing</td>
          <td>1</td>
          <td>ln(3/2) + 1 = 1.41</td>
        </tr>
        <tr>
          <td>suka</td>
          <td>2</td>
          <td>ln(3/3) + 1 = 1.00</td>
        </tr>
        <tr>
          <td>ikan</td>
          <td>1</td>
          <td>ln(3/2) + 1 = 1.41</td>
        </tr>
        <tr>
          <td>anjing</td>
          <td>1</td>
          <td>ln(3/2) + 1 = 1.41</td>
        </tr>
        <tr>
          <td>tulang</td>
          <td>1</td>
          <td>ln(3/2) + 1 = 1.41</td>
        </tr>
      </table>
      <p>
        <em
          >Perhatikan: "suka" punya IDF paling rendah karena muncul di kedua
          dokumen!</em
        >
      </p>

      <h4>Langkah 3: Hitung TF-IDF (TF √ó IDF)</h4>
      <table>
        <tr>
          <th>Kata</th>
          <th>TF-IDF (Doc 0)</th>
          <th>TF-IDF (Doc 1)</th>
        </tr>
        <tr>
          <td>kucing</td>
          <td>0.33 √ó 1.41 = 0.47</td>
          <td>0</td>
        </tr>
        <tr>
          <td>suka</td>
          <td>0.33 √ó 1.00 = 0.33</td>
          <td>0.33 √ó 1.00 = 0.33</td>
        </tr>
        <tr>
          <td>ikan</td>
          <td>0.33 √ó 1.41 = 0.47</td>
          <td>0</td>
        </tr>
        <tr>
          <td>anjing</td>
          <td>0</td>
          <td>0.33 √ó 1.41 = 0.47</td>
        </tr>
        <tr>
          <td>tulang</td>
          <td>0</td>
          <td>0.33 √ó 1.41 = 0.47</td>
        </tr>
      </table>

      <p><strong>Vektor dokumen:</strong></p>
      <ul>
        <li>Doc 0 = [0.47, 0.33, 0.47, 0, 0]</li>
        <li>Doc 1 = [0, 0.33, 0, 0.47, 0.47]</li>
      </ul>

      <h4>Langkah 4: Cosine Similarity</h4>
      <p>
        Dot Product = (0.47√ó0) + (0.33√ó0.33) + (0.47√ó0) + (0√ó0.47) + (0√ó0.47) =
        <strong>0.11</strong>
      </p>
      <p>
        ||Doc 0|| = ‚àö(0.47¬≤ + 0.33¬≤ + 0.47¬≤) = ‚àö0.55 = <strong>0.74</strong>
      </p>
      <p>
        ||Doc 1|| = ‚àö(0.33¬≤ + 0.47¬≤ + 0.47¬≤) = ‚àö0.55 = <strong>0.74</strong>
      </p>
      <p>Cosine Similarity = 0.11 / (0.74 √ó 0.74) = <strong>0.20</strong></p>

      <div class="highlight-box">
        <strong>‚úÖ Kesimpulan:</strong> Kedua dokumen memiliki kemiripan 20%
        karena hanya berbagi kata "suka".
      </div>
    </div>

    <!-- SECTION 4: FUNCTIONAL PROGRAMMING -->
    <h2 id="fp">4. Functional Programming yang Diterapkan</h2>

    <p>
      Project ini menerapkan prinsip-prinsip Functional Programming (FP)
      berikut:
    </p>

    <h3>4.1 Pure Functions</h3>
    <p>
      <strong>Definisi:</strong> Fungsi yang outputnya hanya bergantung pada
      inputnya, tanpa efek samping (side effects).
    </p>

    <div class="code-block">
      <pre><span class="comment">// Pure function - output HANYA bergantung pada input</span>
<span class="keyword">pub fn</span> <span class="function">normalize_text</span>(text: &amp;<span class="type">str</span>) -&gt; <span class="type">String</span> {
    text.chars()
        .map(|c| <span class="keyword">if</span> c.is_ascii_punctuation() { <span class="string">' '</span> } <span class="keyword">else</span> { c.to_ascii_lowercase() })
        .collect()
}

<span class="comment">// Jika input sama, output PASTI sama (tidak ada database, file, atau random)</span></pre>
    </div>

    <div class="highlight-box success">
      <strong>‚úÖ Keuntungan Pure Functions:</strong><br />
      ‚Ä¢ Mudah di-test (tidak perlu mock)<br />
      ‚Ä¢ Mudah dipahami (tidak ada hidden behavior)<br />
      ‚Ä¢ Thread-safe (aman untuk parallel processing)
    </div>

    <h3>4.2 Immutable Data</h3>
    <p>
      <strong>Definisi:</strong> Data yang tidak bisa diubah setelah dibuat.
      Jika butuh perubahan, buat data baru.
    </p>

    <div class="code-block">
      <pre><span class="comment">// Di Rust, variable default-nya immutable</span>
<span class="keyword">let</span> documents = <span class="keyword">vec!</span>[<span class="string">"doc1"</span>, <span class="string">"doc2"</span>];  <span class="comment">// tidak bisa diubah</span>

<span class="comment">// Untuk membuat mutable, harus eksplisit</span>
<span class="keyword">let mut</span> documents = <span class="keyword">vec!</span>[<span class="string">"doc1"</span>];  <span class="comment">// bisa diubah</span></pre>
    </div>

    <h3>4.3 Higher-Order Functions</h3>
    <p>
      <strong>Definisi:</strong> Fungsi yang menerima fungsi lain sebagai
      parameter, atau mengembalikan fungsi.
    </p>

    <div class="code-block">
      <pre><span class="comment">// .map() adalah higher-order function</span>
<span class="comment">// Menerima closure/fungsi sebagai parameter</span>

<span class="keyword">let</span> normalized: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = documents
    .<span class="function">iter</span>()
    .<span class="function">map</span>(|doc| <span class="function">normalize_text</span>(doc))   <span class="comment">// map menerima fungsi</span>
    .<span class="function">collect</span>();

<span class="comment">// Contoh lain: filter, fold, zip</span></pre>
    </div>

    <h3>4.4 Function Composition (Pipeline)</h3>
    <p>
      <strong>Definisi:</strong> Menggabungkan beberapa fungsi kecil menjadi
      satu alur proses.
    </p>

    <div class="code-block">
      <pre><span class="comment">// Pipeline: output fungsi sebelumnya menjadi input fungsi berikutnya</span>

<span class="keyword">pub fn</span> <span class="function">analyze_documents</span>(documents: &amp;[<span class="type">String</span>]) -&gt; SimilarityMatrix {
    <span class="comment">// Stage 1: Normalize</span>
    <span class="keyword">let</span> normalized = documents.par_iter().map(|d| normalize_text(d)).collect();
    
    <span class="comment">// Stage 2: Tokenize (input dari stage 1)</span>
    <span class="keyword">let</span> tokenized = normalized.par_iter().map(|d| tokenize(d)).collect();
    
    <span class="comment">// Stage 3: Compute TF (input dari stage 2)</span>
    <span class="keyword">let</span> tfs = tokenized.par_iter().map(|t| compute_tf(t)).collect();
    
    <span class="comment">// ... dan seterusnya</span>
}</pre>
    </div>

    <div class="diagram">
      <p><strong>Pipeline Flow:</strong></p>
      <div class="pipeline-flow">
        <div class="pipeline-step">normalize</div>
        <div class="pipeline-arrow">‚Üí</div>
        <div class="pipeline-step">tokenize</div>
        <div class="pipeline-arrow">‚Üí</div>
        <div class="pipeline-step">compute_tf</div>
        <div class="pipeline-arrow">‚Üí</div>
        <div class="pipeline-step">compute_idf</div>
        <div class="pipeline-arrow">‚Üí</div>
        <div class="pipeline-step">vectorize</div>
        <div class="pipeline-arrow">‚Üí</div>
        <div class="pipeline-step">similarity</div>
      </div>
    </div>

    <!-- SECTION 5: KODE UTAMA -->
    <h2 id="kode">5. Kode Utama & Penjelasan</h2>

    <h3>5.1 Parallel Processing dengan Rayon</h3>
    <p>
      <strong>Rayon</strong> adalah library yang membuat parallel processing
      sangat mudah di Rust. Cukup ganti <code>.iter()</code> menjadi
      <code>.par_iter()</code>!
    </p>

    <div class="code-block">
      <pre><span class="keyword">use</span> rayon::prelude::*;

<span class="comment">// SEQUENTIAL (satu per satu)</span>
<span class="keyword">let</span> results: <span class="type">Vec</span>&lt;_&gt; = documents
    .<span class="function">iter</span>()                          <span class="comment">// proses satu-satu</span>
    .<span class="function">map</span>(|doc| normalize_text(doc))
    .<span class="function">collect</span>();

<span class="comment">// PARALLEL (semua CPU core dipakai)</span>
<span class="keyword">let</span> results: <span class="type">Vec</span>&lt;_&gt; = documents
    .<span class="function">par_iter</span>()                       <span class="comment">// proses paralel!</span>
    .<span class="function">map</span>(|doc| normalize_text(doc))
    .<span class="function">collect</span>();</pre>
    </div>

    <div class="highlight-box">
      <strong>üí° Kenapa bisa parallel?</strong><br />
      Karena fungsi kita <em>pure</em> (tidak ada side effects), setiap dokumen
      bisa diproses secara independen tanpa khawatir race condition.
    </div>

    <h3>5.2 Pipeline Utama (analyze_documents)</h3>
    <p>Ini adalah fungsi utama yang mengorkestrasi seluruh proses:</p>

    <div class="code-block">
      <pre><span class="keyword">pub fn</span> <span class="function">analyze_documents</span>(documents: &amp;[<span class="type">String</span>]) -&gt; SimilarityMatrix {
    <span class="comment">// Stage 1: Normalize semua dokumen (PARALLEL)</span>
    <span class="keyword">let</span> normalized: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = documents
        .<span class="function">par_iter</span>()
        .<span class="function">map</span>(|doc| normalize_text(doc))
        .<span class="function">collect</span>();

    <span class="comment">// Stage 2: Tokenize (PARALLEL)</span>
    <span class="keyword">let</span> tokenized: <span class="type">Vec</span>&lt;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;&gt; = normalized
        .<span class="function">par_iter</span>()
        .<span class="function">map</span>(|doc| tokenize(doc))
        .<span class="function">collect</span>();

    <span class="comment">// Stage 3: Hitung TF per dokumen (PARALLEL)</span>
    <span class="keyword">let</span> tfs: <span class="type">Vec</span>&lt;_&gt; = tokenized
        .<span class="function">par_iter</span>()
        .<span class="function">map</span>(|tokens| compute_tf(tokens))
        .<span class="function">collect</span>();

    <span class="comment">// Stage 4: Hitung IDF global (SEQUENTIAL - butuh semua TF)</span>
    <span class="keyword">let</span> idf = compute_idf(&amp;tfs);

    <span class="comment">// Stage 5: Build vocabulary</span>
    <span class="keyword">let</span> vocabulary: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = idf.keys().cloned().collect();

    <span class="comment">// Stage 6: Vectorize (PARALLEL)</span>
    <span class="keyword">let</span> vectors: <span class="type">Vec</span>&lt;<span class="type">Vec</span>&lt;<span class="type">f32</span>&gt;&gt; = tfs
        .<span class="function">par_iter</span>()
        .<span class="function">map</span>(|tf| vectorize(tf, &amp;idf, &amp;vocabulary))
        .<span class="function">collect</span>();

    <span class="comment">// Stage 7: Hitung similarity matrix (PARALLEL)</span>
    <span class="keyword">let</span> matrix = compute_similarity_matrix(&amp;vectors);
    
    SimilarityMatrix::new(matrix, labels)
}</pre>
    </div>

    <h3>5.3 Cosine Similarity dalam Kode</h3>

    <div class="code-block">
      <pre><span class="keyword">pub fn</span> <span class="function">cosine_similarity</span>(vec_a: &amp;[<span class="type">f32</span>], vec_b: &amp;[<span class="type">f32</span>]) -&gt; <span class="type">f32</span> {
    <span class="comment">// Hitung dot product: A ¬∑ B</span>
    <span class="keyword">let</span> dot_product: <span class="type">f32</span> = vec_a
        .<span class="function">iter</span>()
        .<span class="function">zip</span>(vec_b.<span class="function">iter</span>())           <span class="comment">// pasangkan elemen</span>
        .<span class="function">map</span>(|(a, b)| a * b)         <span class="comment">// kalikan tiap pasangan</span>
        .<span class="function">sum</span>();                       <span class="comment">// jumlahkan semua</span>

    <span class="comment">// Hitung magnitude (panjang vektor)</span>
    <span class="keyword">let</span> magnitude_a: <span class="type">f32</span> = vec_a.<span class="function">iter</span>().<span class="function">map</span>(|x| x * x).<span class="function">sum</span>::&lt;<span class="type">f32</span>&gt;().<span class="function">sqrt</span>();
    <span class="keyword">let</span> magnitude_b: <span class="type">f32</span> = vec_b.<span class="function">iter</span>().<span class="function">map</span>(|x| x * x).<span class="function">sum</span>::&lt;<span class="type">f32</span>&gt;().<span class="function">sqrt</span>();

    <span class="comment">// Cosine = dot product / (magnitude_a * magnitude_b)</span>
    dot_product / (magnitude_a * magnitude_b)
}</pre>
    </div>

    <h3>5.4 Similarity Matrix (Parallel)</h3>

    <div class="code-block">
      <pre><span class="keyword">pub fn</span> <span class="function">compute_similarity_matrix</span>(vectors: &amp;[<span class="type">Vec</span>&lt;<span class="type">f32</span>&gt;]) -&gt; <span class="type">Vec</span>&lt;<span class="type">Vec</span>&lt;<span class="type">f32</span>&gt;&gt; {
    <span class="keyword">let</span> n = vectors.len();
    
    <span class="comment">// Setiap baris dihitung secara PARALLEL</span>
    (<span class="number">0</span>..n)
        .<span class="function">into_par_iter</span>()                  <span class="comment">// parallel iterator</span>
        .<span class="function">map</span>(|i| {
            (<span class="number">0</span>..n)
                .<span class="function">map</span>(|j| {
                    <span class="keyword">if</span> i == j {
                        <span class="number">1.0</span>  <span class="comment">// diagonal selalu 1.0 (dokumen sama dengan dirinya)</span>
                    } <span class="keyword">else</span> {
                        cosine_similarity(&amp;vectors[i], &amp;vectors[j])
                    }
                })
                .<span class="function">collect</span>()
        })
        .<span class="function">collect</span>()
}</pre>
    </div>

    <!-- SECTION 6: FAQ -->
    <h2 id="faq">6. FAQ - Pertanyaan yang Mungkin Ditanya</h2>

    <h3>Q: Apa hubungan TF-IDF dengan Cosine Similarity?</h3>
    <div class="highlight-box">
      <strong>A:</strong> TF-IDF mengubah teks menjadi vektor angka
      (representasi matematis). Cosine Similarity mengukur kemiripan antar
      vektor tersebut. Jadi TF-IDF adalah <em>cara merepresentasikan</em>,
      Cosine Similarity adalah <em>cara mengukur</em>.
    </div>

    <h3>Q: Kenapa pakai Cosine, bukan Euclidean Distance?</h3>
    <div class="highlight-box">
      <strong>A:</strong> Cosine mengukur <em>arah</em> vektor, bukan
      <em>panjang</em>. Dokumen panjang dan pendek yang membahas topik sama akan
      memiliki arah vektor yang sama, meskipun panjangnya berbeda. Euclidean
      akan menganggap mereka berbeda karena panjang vektornya beda.
    </div>

    <h3>Q: Kenapa IDF pakai logaritma?</h3>
    <div class="highlight-box">
      <strong>A:</strong> Untuk meredam perbedaan yang terlalu ekstrem. Jika
      tanpa log, kata yang muncul di 1 dokumen dari 1000 akan punya nilai 1000x
      lebih tinggi dari kata yang muncul di semua dokumen. Dengan log,
      perbedaannya lebih moderat.
    </div>

    <h3>Q: Kenapa butuh Rayon/parallel processing?</h3>
    <div class="highlight-box">
      <strong>A:</strong> Untuk performa. Jika ada 100 dokumen, perhitungan
      similarity matrix butuh 100√ó100 = 10,000 operasi. Dengan parallel
      processing, kita bisa memanfaatkan semua CPU core sehingga lebih cepat.
    </div>

    <h3>Q: Apa itu Pure Function dan kenapa penting?</h3>
    <div class="highlight-box">
      <strong>A:</strong> Pure function adalah fungsi yang outputnya hanya
      bergantung pada inputnya, tanpa efek samping. Penting karena: (1) mudah
      di-test, (2) thread-safe untuk parallel processing, (3) mudah dipahami dan
      di-debug.
    </div>

    <h3>Q: Bagaimana cara kerja .par_iter()?</h3>
    <div class="highlight-box">
      <strong>A:</strong> Rayon otomatis membagi pekerjaan ke semua CPU core.
      Misalnya jika ada 8 core dan 100 dokumen, setiap core akan memproses
      sekitar 12-13 dokumen secara bersamaan. Programmer tidak perlu mengatur
      thread secara manual.
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
          delimiters: [
            { left: "$$", right: "$$", display: true },
            { left: "$", right: "$", display: false },
          ],
        });
      });
    </script>
  </body>
</html>
